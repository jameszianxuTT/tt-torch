============================= test session starts ==============================
platform linux -- Python 3.11.0rc1, pytest-8.3.5, pluggy-1.5.0 -- /localdev/ddilbaz/tt-torch/env/venv/bin/python3.11
cachedir: .pytest_cache
rootdir: /localdev/ddilbaz/tt-torch
collecting ... collected 2 items

tests/models/resnet/test_resnet.py::test_resnet[True-train] SKIPPED
tests/models/resnet/test_resnet.py::test_resnet[True-eval] Traceback (most recent call last):
  File "/localdev/ddilbaz/tt-torch/env/venv/lib/python3.11/site-packages/torch/fx/passes/shape_prop.py", line 152, in run_node
    result = super().run_node(n)
             ^^^^^^^^^^^^^^^^^^^
  File "/localdev/ddilbaz/tt-torch/env/venv/lib/python3.11/site-packages/torch/fx/interpreter.py", line 203, in run_node
    return getattr(self, n.op)(n.target, args, kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/localdev/ddilbaz/tt-torch/env/venv/lib/python3.11/site-packages/torch/fx/interpreter.py", line 275, in call_function
    return target(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^
  File "/localdev/ddilbaz/tt-torch/env/venv/lib/python3.11/site-packages/torch/_ops.py", line 716, in __call__
    return self._op(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/localdev/ddilbaz/tt-torch/env/venv/lib/python3.11/site-packages/torch/utils/_stats.py", line 21, in wrapper
    return fn(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^
  File "/localdev/ddilbaz/tt-torch/env/venv/lib/python3.11/site-packages/torch/_subclasses/fake_tensor.py", line 1238, in __torch_dispatch__
    return self.dispatch(func, types, args, kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/localdev/ddilbaz/tt-torch/env/venv/lib/python3.11/site-packages/torch/_subclasses/fake_tensor.py", line 1692, in dispatch
    return self._cached_dispatch_impl(func, types, args, kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/localdev/ddilbaz/tt-torch/env/venv/lib/python3.11/site-packages/torch/_subclasses/fake_tensor.py", line 1339, in _cached_dispatch_impl
    output = self._dispatch_impl(func, types, args, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/localdev/ddilbaz/tt-torch/env/venv/lib/python3.11/site-packages/torch/_subclasses/fake_tensor.py", line 1983, in _dispatch_impl
    op_impl_out = op_impl(self, func, *args, **kwargs)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/localdev/ddilbaz/tt-torch/env/venv/lib/python3.11/site-packages/torch/_subclasses/fake_impls.py", line 147, in dispatch_to_op_implementations_dict
    return op_implementations_dict[func](fake_mode, func, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/localdev/ddilbaz/tt-torch/env/venv/lib/python3.11/site-packages/torch/_subclasses/fake_impls.py", line 683, in conv
    conv_backend = torch._C._select_conv_backend(**kwargs)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
RuntimeError: Expected 4-dimensional input for 4-dimensional weight [64, 3, 7, 7], but got 1-dimensional input of size [256] instead
FAILED

=================================== FAILURES ===================================
____________________________ test_resnet[True-eval] ____________________________

self = <torch.fx.passes.shape_prop.ShapeProp object at 0x7f72a3de45d0>
n = convolution

    def run_node(self, n : Node) -> Any:
        try:
            if self.fake_module is not None:
                # Hacky swap. Alternatively, we could do this with overriding
                # call_module and get_attr.
                self.module = self.fake_module
            try:
                if self.fake_mode is not None:
                    with self.fake_mode, enable_python_dispatcher():
>                       result = super().run_node(n)

env/venv/lib/python3.11/site-packages/torch/fx/passes/shape_prop.py:152:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
env/venv/lib/python3.11/site-packages/torch/fx/interpreter.py:203: in run_node
    return getattr(self, n.op)(n.target, args, kwargs)
env/venv/lib/python3.11/site-packages/torch/fx/interpreter.py:275: in call_function
    return target(*args, **kwargs)
env/venv/lib/python3.11/site-packages/torch/_ops.py:716: in __call__
    return self._op(*args, **kwargs)
env/venv/lib/python3.11/site-packages/torch/utils/_stats.py:21: in wrapper
    return fn(*args, **kwargs)
env/venv/lib/python3.11/site-packages/torch/_subclasses/fake_tensor.py:1238: in __torch_dispatch__
    return self.dispatch(func, types, args, kwargs)
env/venv/lib/python3.11/site-packages/torch/_subclasses/fake_tensor.py:1692: in dispatch
    return self._cached_dispatch_impl(func, types, args, kwargs)
env/venv/lib/python3.11/site-packages/torch/_subclasses/fake_tensor.py:1339: in _cached_dispatch_impl
    output = self._dispatch_impl(func, types, args, kwargs)
env/venv/lib/python3.11/site-packages/torch/_subclasses/fake_tensor.py:1983: in _dispatch_impl
    op_impl_out = op_impl(self, func, *args, **kwargs)
env/venv/lib/python3.11/site-packages/torch/_subclasses/fake_impls.py:147: in dispatch_to_op_implementations_dict
    return op_implementations_dict[func](fake_mode, func, *args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

fake_mode = <torch._subclasses.fake_tensor.FakeTensorMode object at 0x7f7285e1d850>
func = <OpOverload(op='aten.convolution', overload='default')>
args = (FakeTensor(..., size=(256,), dtype=torch.bfloat16), FakeTensor(..., size=(64, 3, 7, 7), dtype=torch.bfloat16), None, [2, 2], [3, 3], [1, 1], ...)
kwargs = {'bias': None, 'dilation': [1, 1], 'groups': 1, 'input': FakeTensor(..., size=(256,), dtype=torch.bfloat16), ...}
_ = (), k = 4, batch = 256, has_hint = <function has_hint at 0x7f72a4829b20>

    @register_op_impl([aten.convolution.default, aten.convolution_backward.default])
    def conv(fake_mode, func, *args, **kwargs):
        _, kwargs = normalize_function(
            func, args=args, kwargs=kwargs, normalize_to_only_use_kwargs=True
        )
        device = kwargs["input"].fake_device
        # need to re-enable mode so the tensors report fake device
        with fake_mode:
            # if the input is unsqueezed is done in Convolution.cpp we get segfault
            k = kwargs["weight"].ndim
            batch = kwargs["input"].shape[0]

            # Avoid importing sympy at a module level
            from torch.fx.experimental.symbolic_shapes import has_hint

            if not has_hint(batch):
                # TODO: We can make this a little more faithful with best effort
                # channels last detection (but only if it's statically obvious!)
                mem_fmt = None
            elif k == 3 and not kwargs["input"].is_mkldnn and not kwargs["input"].is_xpu:
                mem_fmt = None
            else:
                if func is aten.convolution.default:
>                   conv_backend = torch._C._select_conv_backend(**kwargs)
E                   RuntimeError: Expected 4-dimensional input for 4-dimensional weight [64, 3, 7, 7], but got 1-dimensional input of size [256] instead

env/venv/lib/python3.11/site-packages/torch/_subclasses/fake_impls.py:683: RuntimeError

The above exception was the direct cause of the following exception:

self = <torch._dynamo.output_graph.OutputGraph object at 0x7f7287574090>
gm = GraphModule(
  (L__self___conv1): Conv2d(3, 64, kernel_size=(7, 7), stride=(2, 2), padding=(3, 3), bias=False)
  (L__s...gpool): AdaptiveAvgPool2d(output_size=(1, 1))
  (L__self___fc): Linear(in_features=512, out_features=1000, bias=True)
)

    def _call_user_compiler(self, gm: fx.GraphModule) -> CompiledFn:
        assert self.compiler_fn is not None
        tot = 0
        placeholders = []
        for node in gm.graph.nodes:
            if node.op in ("call_function", "call_method", "call_module"):
                tot += 1
            if node.op == "placeholder":
                placeholders.append(node)
        increment_op_count(tot)
        for pl in placeholders:
            arg = pl.meta["grapharg"]
            # TODO: Why isn't this stored in meta :think:
            pl._dynamo_source = arg.source

        gm._param_name_to_source = self.param_name_to_source  # type: ignore[assignment]
        gm._source_to_user_stacks = self.source_to_user_stacks  # type: ignore[assignment]

        try:
            name = (
                self.compiler_fn.__name__
                if hasattr(self.compiler_fn, "__name__")
                else ""
            )
            _step_logger()(logging.INFO, f"calling compiler function {name}")
            compiler_fn = self.compiler_fn
            if config.verify_correctness:
                compiler_fn = WrapperBackend(compiler_fn)
>           compiled_fn = compiler_fn(gm, self.example_inputs())

env/venv/lib/python3.11/site-packages/torch/_dynamo/output_graph.py:1446:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
env/venv/lib/python3.11/site-packages/torch/_dynamo/repro/after_dynamo.py:129: in __call__
    compiled_gm = compiler_fn(gm, example_inputs)
env/venv/lib/python3.11/site-packages/torch/__init__.py:2280: in __call__
    return self.compiler_fn(model_, inputs_, **self.kwargs)
tt_torch/dynamo/backend.py:521: in backend
    return aot_module_simplified(
env/venv/lib/python3.11/site-packages/torch/_functorch/aot_autograd.py:1071: in aot_module_simplified
    compiled_fn = dispatch_and_compile()
env/venv/lib/python3.11/site-packages/torch/_functorch/aot_autograd.py:1056: in dispatch_and_compile
    compiled_fn, _ = create_aot_dispatcher_function(
env/venv/lib/python3.11/site-packages/torch/_functorch/aot_autograd.py:522: in create_aot_dispatcher_function
    return _create_aot_dispatcher_function(
env/venv/lib/python3.11/site-packages/torch/_functorch/aot_autograd.py:759: in _create_aot_dispatcher_function
    compiled_fn, fw_metadata = compiler_fn(
env/venv/lib/python3.11/site-packages/torch/_functorch/_aot_autograd/jit_compile_runtime_wrappers.py:179: in aot_dispatch_base
    compiled_fw = compiler(fw_module, updated_flat_args)
tt_torch/dynamo/backend.py:472: in _base_backend
    gm, graph_constants = pass_pipeline(gm, example_inputs, compiler_config)
tt_torch/dynamo/passes.py:257: in pass_pipeline
    run_shape_prop(gm, example_inputs + constant_inputs)
tt_torch/dynamo/passes.py:31: in run_shape_prop
    shape_prop.run(*fake_args)
env/venv/lib/python3.11/site-packages/torch/fx/interpreter.py:146: in run
    self.env[node] = self.run_node(node)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <torch.fx.passes.shape_prop.ShapeProp object at 0x7f72a3de45d0>
n = convolution

    def run_node(self, n : Node) -> Any:
        try:
            if self.fake_module is not None:
                # Hacky swap. Alternatively, we could do this with overriding
                # call_module and get_attr.
                self.module = self.fake_module
            try:
                if self.fake_mode is not None:
                    with self.fake_mode, enable_python_dispatcher():
                        result = super().run_node(n)
                else:
                    result = super().run_node(n)
            finally:
                self.module = self.real_module
        except Exception as e:
            traceback.print_exc()
>           raise RuntimeError(
                f"ShapeProp error for: node={n.format_node()} with "
                f"meta={n.meta}"
            ) from e
E           RuntimeError: ShapeProp error for: node=%convolution : [num_users=1] = call_function[target=torch.ops.aten.convolution.default](args = (%arg122_1, %arg0_1, None, [2, 2], [3, 3], [1, 1], False, [0, 0], 1), kwargs = {}) with meta={'stack_trace': '  File "/localdev/ddilbaz/tt-torch/env/venv/lib/python3.11/site-packages/torchvision-0.20.0a0+afc54f7-py3.11-linux-x86_64.egg/torchvision/models/resnet.py", line 285, in forward\n    return self._forward_impl(x)\n  File "/localdev/ddilbaz/tt-torch/env/venv/lib/python3.11/site-packages/torchvision-0.20.0a0+afc54f7-py3.11-linux-x86_64.egg/torchvision/models/resnet.py", line 268, in _forward_impl\n    x = self.conv1(x)\n', 'nn_module_stack': {'L__self___conv1': ("L['self'].conv1", <class 'torch.nn.modules.conv.Conv2d'>)}, 'source_fn_stack': [('l__self___conv1', <class 'torch.nn.modules.conv.Conv2d'>)], 'original_aten': <OpOverload(op='aten.convolution', overload='default')>, 'from_node': [('x', 'L__self___conv1')], 'seq_nr': 247, 'val': FakeTensor(..., size=(1, 64, 112, 112), dtype=torch.bfloat16), 'tensor_meta': TensorMetadata(shape=torch.Size([1, 64, 112, 112]), dtype=torch.bfloat16, requires_grad=False, stride=(802816, 12544, 112, 1), memory_format=torch.contiguous_format, is_quantized=False, qparams={})}
E
E           While executing %convolution : [num_users=1] = call_function[target=torch.ops.aten.convolution.default](args = (%arg122_1, %arg0_1, None, [2, 2], [3, 3], [1, 1], False, [0, 0], 1), kwargs = {})
E           Original traceback:
E             File "/localdev/ddilbaz/tt-torch/env/venv/lib/python3.11/site-packages/torchvision-0.20.0a0+afc54f7-py3.11-linux-x86_64.egg/torchvision/models/resnet.py", line 285, in forward
E               return self._forward_impl(x)
E             File "/localdev/ddilbaz/tt-torch/env/venv/lib/python3.11/site-packages/torchvision-0.20.0a0+afc54f7-py3.11-linux-x86_64.egg/torchvision/models/resnet.py", line 268, in _forward_impl
E               x = self.conv1(x)

env/venv/lib/python3.11/site-packages/torch/fx/passes/shape_prop.py:159: RuntimeError

The above exception was the direct cause of the following exception:

record_property = <function record_property.<locals>.append_property at 0x7f728752c400>
mode = 'eval', nightly = True

    @pytest.mark.parametrize(
        "mode",
        ["train", "eval"],
    )
    def test_resnet(record_property, mode, nightly):
        if mode == "train":
            pytest.skip()
        model_name = "ResNet18"
        record_property("model_name", model_name)
        record_property("mode", mode)

        cc = CompilerConfig()
        cc.enable_consteval = True
        cc.consteval_parameters = True
        if nightly:
            cc.compile_depth = CompileDepth.EXECUTE_OP_BY_OP

        tester = ThisTester(model_name, mode, compiler_config=cc)
>       results = tester.test_model()

tests/models/resnet/test_resnet.py:41:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests/utils.py:165: in test_model
    return self.test_model_eval(on_device)
env/venv/lib/python3.11/site-packages/torch/utils/_contextlib.py:116: in decorate_context
    return func(*args, **kwargs)
tests/utils.py:157: in test_model_eval
    outputs = self.run_model(model, inputs)
tests/utils.py:85: in run_model
    return model(inputs)
env/venv/lib/python3.11/site-packages/torch/nn/modules/module.py:1736: in _wrapped_call_impl
    return self._call_impl(*args, **kwargs)
env/venv/lib/python3.11/site-packages/torch/nn/modules/module.py:1747: in _call_impl
    return forward_call(*args, **kwargs)
env/venv/lib/python3.11/site-packages/torch/_dynamo/eval_frame.py:465: in _fn
    return fn(*args, **kwargs)
env/venv/lib/python3.11/site-packages/torch/nn/modules/module.py:1736: in _wrapped_call_impl
    return self._call_impl(*args, **kwargs)
env/venv/lib/python3.11/site-packages/torch/nn/modules/module.py:1747: in _call_impl
    return forward_call(*args, **kwargs)
env/venv/lib/python3.11/site-packages/torch/_dynamo/convert_frame.py:1269: in __call__
    return self._torchdynamo_orig_callable(
env/venv/lib/python3.11/site-packages/torch/_dynamo/convert_frame.py:1064: in __call__
    result = self._inner_convert(
env/venv/lib/python3.11/site-packages/torch/_dynamo/convert_frame.py:526: in __call__
    return _compile(
env/venv/lib/python3.11/site-packages/torch/_dynamo/convert_frame.py:924: in _compile
    guarded_code = compile_inner(code, one_graph, hooks, transform)
env/venv/lib/python3.11/site-packages/torch/_dynamo/convert_frame.py:666: in compile_inner
    return _compile_inner(code, one_graph, hooks, transform)
env/venv/lib/python3.11/site-packages/torch/_utils_internal.py:87: in wrapper_function
    return function(*args, **kwargs)
env/venv/lib/python3.11/site-packages/torch/_dynamo/convert_frame.py:699: in _compile_inner
    out_code = transform_code_object(code, transform)
env/venv/lib/python3.11/site-packages/torch/_dynamo/bytecode_transformation.py:1322: in transform_code_object
    transformations(instructions, code_options)
env/venv/lib/python3.11/site-packages/torch/_dynamo/convert_frame.py:219: in _fn
    return fn(*args, **kwargs)
env/venv/lib/python3.11/site-packages/torch/_dynamo/convert_frame.py:634: in transform
    tracer.run()
env/venv/lib/python3.11/site-packages/torch/_dynamo/symbolic_convert.py:2796: in run
    super().run()
env/venv/lib/python3.11/site-packages/torch/_dynamo/symbolic_convert.py:983: in run
    while self.step():
env/venv/lib/python3.11/site-packages/torch/_dynamo/symbolic_convert.py:895: in step
    self.dispatch_table[inst.opcode](self, inst)
env/venv/lib/python3.11/site-packages/torch/_dynamo/symbolic_convert.py:2987: in RETURN_VALUE
    self._return(inst)
env/venv/lib/python3.11/site-packages/torch/_dynamo/symbolic_convert.py:2972: in _return
    self.output.compile_subgraph(
env/venv/lib/python3.11/site-packages/torch/_dynamo/output_graph.py:1117: in compile_subgraph
    self.compile_and_call_fx_graph(tx, list(reversed(stack_values)), root)
env/venv/lib/python3.11/site-packages/torch/_dynamo/output_graph.py:1369: in compile_and_call_fx_graph
    compiled_fn = self.call_user_compiler(gm)
env/venv/lib/python3.11/site-packages/torch/_dynamo/output_graph.py:1416: in call_user_compiler
    return self._call_user_compiler(gm)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <torch._dynamo.output_graph.OutputGraph object at 0x7f7287574090>
gm = GraphModule(
  (L__self___conv1): Conv2d(3, 64, kernel_size=(7, 7), stride=(2, 2), padding=(3, 3), bias=False)
  (L__s...gpool): AdaptiveAvgPool2d(output_size=(1, 1))
  (L__self___fc): Linear(in_features=512, out_features=1000, bias=True)
)

    def _call_user_compiler(self, gm: fx.GraphModule) -> CompiledFn:
        assert self.compiler_fn is not None
        tot = 0
        placeholders = []
        for node in gm.graph.nodes:
            if node.op in ("call_function", "call_method", "call_module"):
                tot += 1
            if node.op == "placeholder":
                placeholders.append(node)
        increment_op_count(tot)
        for pl in placeholders:
            arg = pl.meta["grapharg"]
            # TODO: Why isn't this stored in meta :think:
            pl._dynamo_source = arg.source

        gm._param_name_to_source = self.param_name_to_source  # type: ignore[assignment]
        gm._source_to_user_stacks = self.source_to_user_stacks  # type: ignore[assignment]

        try:
            name = (
                self.compiler_fn.__name__
                if hasattr(self.compiler_fn, "__name__")
                else ""
            )
            _step_logger()(logging.INFO, f"calling compiler function {name}")
            compiler_fn = self.compiler_fn
            if config.verify_correctness:
                compiler_fn = WrapperBackend(compiler_fn)
            compiled_fn = compiler_fn(gm, self.example_inputs())
            _step_logger()(logging.INFO, f"done compiler function {name}")
            assert callable(compiled_fn), "compiler_fn did not return callable"
        except exceptions_allowed_to_be_fallback as e:
            if self.has_user_defined_allowed_in_graph:
                raise BackendCompilerFailed(self.compiler_fn, e).with_traceback(
                    e.__traceback__
                ) from None
            msg = (
                "Backend compiler failed with a fake tensor exception at \n"
                f"{self.root_tx.format_frame_summary()}"
                "Adding a graph break."
            )
            unimplemented_with_warning(e, self.root_tx.f_code, msg)
        except SkipFrame as e:
            # The backend compiler has requested that we skip the frame, instead of
            # aborting execution.
            raise e
        except Exception as e:
>           raise BackendCompilerFailed(self.compiler_fn, e) from e
E           torch._dynamo.exc.BackendCompilerFailed: backend='backend' raised:
E           RuntimeError: ShapeProp error for: node=%convolution : [num_users=1] = call_function[target=torch.ops.aten.convolution.default](args = (%arg122_1, %arg0_1, None, [2, 2], [3, 3], [1, 1], False, [0, 0], 1), kwargs = {}) with meta={'stack_trace': '  File "/localdev/ddilbaz/tt-torch/env/venv/lib/python3.11/site-packages/torchvision-0.20.0a0+afc54f7-py3.11-linux-x86_64.egg/torchvision/models/resnet.py", line 285, in forward\n    return self._forward_impl(x)\n  File "/localdev/ddilbaz/tt-torch/env/venv/lib/python3.11/site-packages/torchvision-0.20.0a0+afc54f7-py3.11-linux-x86_64.egg/torchvision/models/resnet.py", line 268, in _forward_impl\n    x = self.conv1(x)\n', 'nn_module_stack': {'L__self___conv1': ("L['self'].conv1", <class 'torch.nn.modules.conv.Conv2d'>)}, 'source_fn_stack': [('l__self___conv1', <class 'torch.nn.modules.conv.Conv2d'>)], 'original_aten': <OpOverload(op='aten.convolution', overload='default')>, 'from_node': [('x', 'L__self___conv1')], 'seq_nr': 247, 'val': FakeTensor(..., size=(1, 64, 112, 112), dtype=torch.bfloat16), 'tensor_meta': TensorMetadata(shape=torch.Size([1, 64, 112, 112]), dtype=torch.bfloat16, requires_grad=False, stride=(802816, 12544, 112, 1), memory_format=torch.contiguous_format, is_quantized=False, qparams={})}
E
E           While executing %convolution : [num_users=1] = call_function[target=torch.ops.aten.convolution.default](args = (%arg122_1, %arg0_1, None, [2, 2], [3, 3], [1, 1], False, [0, 0], 1), kwargs = {})
E           Original traceback:
E             File "/localdev/ddilbaz/tt-torch/env/venv/lib/python3.11/site-packages/torchvision-0.20.0a0+afc54f7-py3.11-linux-x86_64.egg/torchvision/models/resnet.py", line 285, in forward
E               return self._forward_impl(x)
E             File "/localdev/ddilbaz/tt-torch/env/venv/lib/python3.11/site-packages/torchvision-0.20.0a0+afc54f7-py3.11-linux-x86_64.egg/torchvision/models/resnet.py", line 268, in _forward_impl
E               x = self.conv1(x)
E
E
E           Set TORCH_LOGS="+dynamo" and TORCHDYNAMO_VERBOSE=1 for more information
E
E
E           You can suppress this exception and fall back to eager by setting:
E               import torch._dynamo
E               torch._dynamo.config.suppress_errors = True

env/venv/lib/python3.11/site-packages/torch/_dynamo/output_graph.py:1465: BackendCompilerFailed
=============================== warnings summary ===============================
tests/models/resnet/test_resnet.py::test_resnet[True-eval]
  /localdev/ddilbaz/tt-torch/env/venv/lib/python3.11/site-packages/torchvision-0.20.0a0+afc54f7-py3.11-linux-x86_64.egg/torchvision/models/_utils.py:208: UserWarning: The parameter 'pretrained' is deprecated since 0.13 and may be removed in the future, please use 'weights' instead.
    warnings.warn(

tests/models/resnet/test_resnet.py::test_resnet[True-eval]
  /localdev/ddilbaz/tt-torch/env/venv/lib/python3.11/site-packages/torchvision-0.20.0a0+afc54f7-py3.11-linux-x86_64.egg/torchvision/models/_utils.py:223: UserWarning: Arguments other than a weight enum or `None` for 'weights' are deprecated since 0.13 and may be removed in the future. The current behavior is equivalent to passing `weights=ResNet18_Weights.IMAGENET1K_V1`. You can also use `weights=ResNet18_Weights.DEFAULT` to get the most up-to-date weights.
    warnings.warn(msg)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED tests/models/resnet/test_resnet.py::test_resnet[True-eval] - torch._dynamo.exc.BackendCompilerFailed: backend='backend' raised:
RuntimeError: ShapeProp error for: node=%convolution : [num_users=1] = call_function[target=torch.ops.aten.convolution.default](args = (%arg122_1, %arg0_1, None, [2, 2], [3, 3], [1, 1], False, [0, 0], 1), kwargs = {}) with meta={'stack_trace': '  File "/localdev/ddilbaz/tt-torch/env/venv/lib/python3.11/site-packages/torchvision-0.20.0a0+afc54f7-py3.11-linux-x86_64.egg/torchvision/models/resnet.py", line 285, in forward\n    return self._forward_impl(x)\n  File "/localdev/ddilbaz/tt-torch/env/venv/lib/python3.11/site-packages/torchvision-0.20.0a0+afc54f7-py3.11-linux-x86_64.egg/torchvision/models/resnet.py", line 268, in _forward_impl\n    x = self.conv1(x)\n', 'nn_module_stack': {'L__self___conv1': ("L['self'].conv1", <class 'torch.nn.modules.conv.Conv2d'>)}, 'source_fn_stack': [('l__self___conv1', <class 'torch.nn.modules.conv.Conv2d'>)], 'original_aten': <OpOverload(op='aten.convolution', overload='default')>, 'from_node': [('x', 'L__self___conv1')], 'seq_nr': 247, 'val': FakeTensor(..., size=(1, 64, 112, 112), dtype=torch.bfloat16), 'tensor_meta': TensorMetadata(shape=torch.Size([1, 64, 112, 112]), dtype=torch.bfloat16, requires_grad=False, stride=(802816, 12544, 112, 1), memory_format=torch.contiguous_format, is_quantized=False, qparams={})}

While executing %convolution : [num_users=1] = call_function[target=torch.ops.aten.convolution.default](args = (%arg122_1, %arg0_1, None, [2, 2], [3, 3], [1, 1], False, [0, 0], 1), kwargs = {})
Original traceback:
  File "/localdev/ddilbaz/tt-torch/env/venv/lib/python3.11/site-packages/torchvision-0.20.0a0+afc54f7-py3.11-linux-x86_64.egg/torchvision/models/resnet.py", line 285, in forward
    return self._forward_impl(x)
  File "/localdev/ddilbaz/tt-torch/env/venv/lib/python3.11/site-packages/torchvision-0.20.0a0+afc54f7-py3.11-linux-x86_64.egg/torchvision/models/resnet.py", line 268, in _forward_impl
    x = self.conv1(x)


Set TORCH_LOGS="+dynamo" and TORCHDYNAMO_VERBOSE=1 for more information


You can suppress this exception and fall back to eager by setting:
    import torch._dynamo
    torch._dynamo.config.suppress_errors = True
=================== 1 failed, 1 skipped, 2 warnings in 2.39s ===================
